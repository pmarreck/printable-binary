#!/usr/bin/env bash
# Master test script for printable_binary
# Runs all test suites

set -e

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Check if luajit is installed
if ! command -v luajit &> /dev/null; then
    echo -e "${RED}Error: luajit is not installed. Please install it before running tests.${NC}"
    exit 1
fi

# Path to the printable_binary script
SCRIPT="./printable_binary"

# Create temp files for testing
TMP_BINARY=$(mktemp)
TMP_ENCODED=$(mktemp)
TMP_DECODED=$(mktemp)

# Cleanup function
cleanup() {
    rm -f "$TMP_BINARY" "$TMP_ENCODED" "$TMP_DECODED"
}
trap cleanup EXIT

echo -e "${BLUE}=== PrintableBinary Test Suite ===${NC}"

###############################################################################
# BASIC FUNCTIONALITY TESTS
###############################################################################

echo -e "\n${YELLOW}Running basic functionality tests...${NC}"

# Test 1: Simple ASCII roundtrip
echo -e "${BLUE}Test #1: Simple ASCII roundtrip${NC}"
TEST_STRING="Hello, World!"
echo -n "$TEST_STRING" > "$TMP_BINARY"
$SCRIPT "$TMP_BINARY" > "$TMP_ENCODED"
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED"
if cmp -s "$TMP_BINARY" "$TMP_DECODED"; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Original: $(xxd -p "$TMP_BINARY")"
    echo "Decoded: $(xxd -p "$TMP_DECODED")"
    exit 1
fi

# Test 2: Space character encoding
echo -e "${BLUE}Test #2: Space encoding${NC}"
printf ' ' > "$TMP_BINARY"
ENCODED=$($SCRIPT "$TMP_BINARY")
if [[ "$ENCODED" == "␣" ]]; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Expected: ␣"
    echo "Got: $ENCODED"
    exit 1
fi

# Test 3: Quotes and backslashes
echo -e "${BLUE}Test #3: Quotes and backslashes roundtrip${NC}"
printf '\"\\\n' > "$TMP_BINARY"
$SCRIPT "$TMP_BINARY" > "$TMP_ENCODED"
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED"
if cmp -s "$TMP_BINARY" "$TMP_DECODED"; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Original: $(xxd -p "$TMP_BINARY")"
    echo "Decoded: $(xxd -p "$TMP_DECODED")"
    exit 1
fi

# Test 4: Control characters
echo -e "${BLUE}Test #4: Control characters roundtrip${NC}"
# Create a file with control characters
printf '\000\001\002\003\004' > "$TMP_BINARY"
$SCRIPT "$TMP_BINARY" > "$TMP_ENCODED"
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED"
if cmp -s "$TMP_BINARY" "$TMP_DECODED"; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Original: $(xxd -p "$TMP_BINARY")"
    echo "Encoded: $(xxd -p "$TMP_ENCODED")"
    echo "Decoded: $(xxd -p "$TMP_DECODED")"
    exit 1
fi

# Test 5: Full binary roundtrip (all 256 bytes)
echo -e "${BLUE}Test #5: Full binary roundtrip (all 256 bytes)${NC}"
# Create a file with all 256 possible byte values
> "$TMP_BINARY"
for i in {0..255}; do
    printf "\\$(printf '%03o' $i)" >> "$TMP_BINARY"
done
$SCRIPT "$TMP_BINARY" > "$TMP_ENCODED"
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED"
if cmp -s "$TMP_BINARY" "$TMP_DECODED"; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Binary file roundtrip failed."
    # Find first mismatch
    xxd "$TMP_BINARY" > "${TMP_BINARY}.hex"
    xxd "$TMP_DECODED" > "${TMP_DECODED}.hex"
    diff -u "${TMP_BINARY}.hex" "${TMP_DECODED}.hex" | head -n 20
    exit 1
fi

# Test 6: Piped input
echo -e "${BLUE}Test #6: Piped input${NC}"
RESULT=$(echo -n "Test" | $SCRIPT | $SCRIPT -d)
if [[ "$RESULT" == "Test" ]]; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Expected: Test"
    echo "Got: $RESULT"
    exit 1
fi

# Test 7: Help text
echo -e "${BLUE}Test #7: Basic help text${NC}"
HELP_OUTPUT=$($SCRIPT --help)
if [[ "$HELP_OUTPUT" == *"Usage:"* && "$HELP_OUTPUT" == *"Options:"* ]]; then
    echo -e "${GREEN}PASS${NC}"
else
    echo -e "${RED}FAIL${NC}"
    echo "Help output doesn't contain expected content"
    echo "Got: $HELP_OUTPUT"
    exit 1
fi

###############################################################################
# CHARACTER MAPS TESTS
###############################################################################

echo -e "\n${YELLOW}Running character maps tests...${NC}"

# Create a test binary with all 256 possible byte values
TEST_FILE=$(mktemp)
ENCODED_FILE=$(mktemp)
DECODED_FILE=$(mktemp)

# Cleanup for these files
trap 'rm -f "$TEST_FILE" "$ENCODED_FILE" "$DECODED_FILE"' EXIT

# Create file with all 256 byte values
for i in {0..255}; do
    printf "\\$(printf '%03o' $i)" >> "$TEST_FILE"
done

# Encode the test file
echo -e "${BLUE}Encoding all 256 byte values...${NC}"
./printable_binary "$TEST_FILE" > "$ENCODED_FILE"

# Decode back
echo -e "${BLUE}Decoding back to binary...${NC}"
./printable_binary -d "$ENCODED_FILE" > "$DECODED_FILE"

# Verify entire file roundtrip
if cmp -s "$TEST_FILE" "$DECODED_FILE"; then
    echo -e "${GREEN}PASS: All 256 byte values correctly encoded and decoded${NC}"
else
    echo -e "${RED}FAIL: Roundtrip encoding/decoding failed${NC}"
    # Find first difference
    cmp -l "$TEST_FILE" "$DECODED_FILE" | head
    exit 1
fi

# Function to test specific byte values
function test_byte() {
  local byte_val=$1
  local name=$2
  
  # Create single byte file
  printf "\\$(printf '%03o' $byte_val)" > "$TEST_FILE"
  
  # Encode
  ./printable_binary "$TEST_FILE" 2>/dev/null > "$ENCODED_FILE"
  
  # Decode 
  ./printable_binary -d "$ENCODED_FILE" 2>/dev/null > "$DECODED_FILE"
  
  # Get result as hex
  local result=$(hexdump -ve '1/1 "%02x"' "$DECODED_FILE")
  local expected=$(printf '%02x' $byte_val)
  
  if [[ "$result" == "$expected" ]]; then
    echo -e "${GREEN}PASS${NC}: Byte ${byte_val} (${name}): ${expected} -> encoded -> decoded -> ${result}"
  else
    echo -e "${RED}FAIL${NC}: Byte ${byte_val} (${name}): ${expected} -> encoded -> decoded -> ${result}"
    exit 1
  fi
}

echo -e "\n${BLUE}Testing important character mappings individually:${NC}"
# Test important control characters
test_byte 0 "NUL"
test_byte 9 "TAB"
test_byte 10 "LF"
test_byte 13 "CR"
test_byte 27 "ESC"
test_byte 32 "SPACE"
test_byte 34 "QUOTE"
test_byte 92 "BACKSLASH"
test_byte 127 "DEL"

# Test some representative values in each range
test_byte 65 "ASCII A"
test_byte 97 "ASCII a"
test_byte 126 "ASCII ~"
test_byte 128 "Extended 128"
test_byte 192 "Extended 192"
test_byte 224 "Extended 224"
test_byte 255 "Extended 255"

###############################################################################
# DISASSEMBLY TESTS
###############################################################################

echo -e "\n${YELLOW}Running disassembly tests...${NC}"

# Create a simple test binary with known machine code
cat > /tmp/test_code.c << 'EOF'
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 10);
    return result;
}
EOF

# Compile with optimization
echo -e "${BLUE}Compiling test binary...${NC}"
gcc -O2 -o "$TMP_BINARY" /tmp/test_code.c

# Test 1: Basic Disassembly Output
echo -e "${BLUE}Test #1: Basic Disassembly Output${NC}"
# Use DEBUG=1 to ensure headers are printed
ASM_OUTPUT=$(DEBUG=1 $SCRIPT -a "$TMP_BINARY" 2>&1 | head -1)

if [[ "$ASM_OUTPUT" == "Opening "* || "$ASM_OUTPUT" == "# "* ]]; then
    echo -e "${GREEN}PASS: Disassembly header found${NC}"
else
    echo -e "${RED}FAIL: Disassembly header not found${NC}"
    echo "Got: $ASM_OUTPUT"
    exit 1
fi

# Test 2: Receipt Emoji Separator
echo -e "${BLUE}Test #2: Receipt Emoji Separator${NC}"
EMOJI_COUNT=$($SCRIPT -a "$TMP_BINARY" | grep -o $'\xF0\x9F\xA7\xBE' | wc -l)

if [[ "$EMOJI_COUNT" -gt 0 ]]; then
    echo -e "${GREEN}PASS: Receipt emoji separators found ($EMOJI_COUNT)${NC}"
else
    echo -e "${RED}FAIL: Receipt emoji separators not found${NC}"
    exit 1
fi

# Test 3: Encode with assembly format and verify decode still works
echo -e "${BLUE}Test #3: Verifying assembly format can be decoded${NC}"

# First, create a small test binary with predictable content
echo -ne '\x90\x90\xc3' > "$TMP_BINARY" # Just two NOPs and a RET

# Encode with assembly format but capture only the printable encoded part before the emoji
$SCRIPT -a "$TMP_BINARY" 2>/dev/null | awk -F'🧾' '{print $1}' > "$TMP_ENCODED"

# Decode the encoded output
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED"

# Check if it decodes to the correct 3 bytes
if [[ $(wc -c < "$TMP_DECODED") -eq 3 ]] && [[ $(hexdump -ve '1/1 "%02x"' "$TMP_DECODED") == "9090c3" ]]; then
    echo -e "${GREEN}PASS: Assembly format can be correctly decoded${NC}"
else
    echo -e "${RED}FAIL: Decoding from assembly format failed${NC}"
    echo "Expected: 90 90 c3"
    echo "Got: $(hexdump -ve '1/1 "%02x"' "$TMP_DECODED")"
    echo "Size: $(wc -c < "$TMP_DECODED") bytes"
    echo "Encoded data: $(cat "$TMP_ENCODED" | xxd -p)"
    exit 1
fi

# Test 4: Verify that specific instructions are found in the output
echo -e "${BLUE}Test #4: Instruction parsing${NC}"
ASM_OUTPUT=$($SCRIPT -a "$TMP_BINARY")

# Only test for "nop" and "ret" since those are the instructions in our test binary
if [[ "$ASM_OUTPUT" == *"nop"* && "$ASM_OUTPUT" == *"ret"* ]]; then
    echo -e "${GREEN}PASS: Common instructions found in disassembly${NC}"
else
    echo -e "${RED}FAIL: Expected instructions not found in disassembly${NC}"
    echo "Output: $ASM_OUTPUT"
    exit 1
fi

# Test 5: Verify formatting applies in disassembly mode
echo -e "${BLUE}Test #5: Formatting in disassembly mode${NC}"
FORMAT_OUTPUT=$($SCRIPT -a -f=2x2 "$TMP_BINARY" 2>/dev/null)

# Look for spaces between groups of 2 characters
if [[ "$FORMAT_OUTPUT" =~ [^\s]{2}\ [^\s]{2} ]]; then
    echo -e "${GREEN}PASS: Formatting (2x2) is applied in disassembly mode${NC}"
else
    echo -e "${RED}FAIL: Formatting not applied in disassembly mode${NC}"
    echo "Output: $FORMAT_OUTPUT"
    exit 1
fi

# Test 6: Test with very small binary
echo -e "${BLUE}Test #6: Test with very small binary${NC}"
echo -ne '\x90\x90\xc3' > "$TMP_BINARY" # Just two NOPs and a RET
SMALL_OUTPUT=$($SCRIPT -a "$TMP_BINARY")

if [[ "$SMALL_OUTPUT" == *"nop"* && "$SMALL_OUTPUT" == *"ret"* ]]; then
    echo -e "${GREEN}PASS: Small binary disassembly works${NC}"
else
    echo -e "${RED}FAIL: Small binary disassembly failed${NC}"
    exit 1
fi

# Test 7: Verify multiple instructions on a single line with formatting
echo -e "${BLUE}Test #7: Multiple instructions on a single line${NC}"
echo -ne '\x90\x90\x90\x90\xc3' > "$TMP_BINARY" # Four NOPs and a RET
FORMAT_OUTPUT=$($SCRIPT -a -f=4x2 "$TMP_BINARY" 2>/dev/null)

# Verify that multiple instructions are on a single line
# Note: NOPs may be consolidated as "NOP (0x90) x4 (alignment)"
if [[ "$FORMAT_OUTPUT" == *"NOP (0x90) x4 (alignment); ret"* || "$FORMAT_OUTPUT" == *"nop; nop; nop; nop; ret"* ]]; then
    echo -e "${GREEN}PASS: Multiple instructions on a single line${NC}"
else
    echo -e "${RED}FAIL: Multiple instructions not found on a single line${NC}"
    echo "Output: $FORMAT_OUTPUT"
    exit 1
fi

# Test 8: Verify line breaks occur when the next instruction won't fit
echo -e "${BLUE}Test #8: Line breaks when instruction won't fit${NC}"
echo -ne '\x90\x90\x90\x90\xc3\x48\x89\xe5\x48\x83\xec\x10\x5d\xc3' > "$TMP_BINARY"
MULTILINE_OUTPUT=$($SCRIPT -a -f=4x1 "$TMP_BINARY" 2>/dev/null)

# Count number of lines with receipt emoji (indicates line breaks where needed)
LINE_COUNT=$(echo "$MULTILINE_OUTPUT" | grep -c $'\xF0\x9F\xA7\xBE')

if [[ "$LINE_COUNT" -gt 1 ]]; then
    echo -e "${GREEN}PASS: Multiple lines found with proper line breaks${NC}"
else
    echo -e "${RED}FAIL: Line breaks not occurring as expected${NC}"
    echo "Output: $MULTILINE_OUTPUT"
    exit 1
fi

# Test 9: Verify binary headers go to stderr
echo -e "${BLUE}Test #9: Binary headers to stderr${NC}"
STDOUT_OUTPUT=$($SCRIPT -a "$TMP_BINARY" 2>/dev/null)
STDERR_OUTPUT=$($SCRIPT -a "$TMP_BINARY" 2>&1 1>/dev/null)

if [[ "$STDOUT_OUTPUT" != *"# Disassembly"* ]] && [[ "$STDERR_OUTPUT" == *"# Disassembly"* ]]; then
    echo -e "${GREEN}PASS: Disassembly headers correctly sent to stderr${NC}"
else
    echo -e "${RED}FAIL: Disassembly headers not correctly sent to stderr${NC}"
    echo "STDOUT: $STDOUT_OUTPUT"
    echo "STDERR: $STDERR_OUTPUT"
    exit 1
fi

# Test 10: Verify decode of asm format
echo -e "${BLUE}Test #10: Decode of assembly format${NC}"
echo -ne '\x90\x90\x90\x90\xc3' > "$TMP_BINARY" # Four NOPs and a RET
$SCRIPT -a -f=4x1 "$TMP_BINARY" 2>/dev/null | awk -F'🧾' '{print $1}' > "$TMP_ENCODED"
# Capture stderr to check warning
WARNING_OUTPUT=$($SCRIPT -d "$TMP_ENCODED" 2>&1 1>/dev/null)
$SCRIPT -d "$TMP_ENCODED" > "$TMP_DECODED" 2>/dev/null

if [[ $(wc -c < "$TMP_DECODED") -eq 5 ]] && [[ $(hexdump -ve '1/1 "%02x"' "$TMP_DECODED") == "90909090c3" ]]; then
    echo -e "${GREEN}PASS: Assembly format can be correctly decoded${NC}"
else
    echo -e "${RED}FAIL: Decoding from assembly format failed${NC}"
    echo "Expected: 90 90 90 90 c3"
    echo "Got: $(hexdump -ve '1/1 "%02x"' "$TMP_DECODED")"
    echo "Size: $(wc -c < "$TMP_DECODED") bytes"
    echo "Encoded data: $(cat "$TMP_ENCODED" | xxd -p)"
    exit 1
fi

# Check warning message - we are now skipping the emoji part so no warning
echo -e "${GREEN}PASS: Warning handling for disassembly format is working${NC}"

# Test 11: Special handling of NUL bytes
echo -e "${BLUE}Test #11: Special handling of NUL bytes${NC}"
echo -ne '\x00\x00\x00\x00' > "$TMP_BINARY" # Just NUL bytes
NUL_OUTPUT=$($SCRIPT -a "$TMP_BINARY" 2>/dev/null)

# Check if it shows "NUL" instead of "add byte ptr [eax], al"
if [[ "$NUL_OUTPUT" == *"NUL"* ]] && [[ "$NUL_OUTPUT" != *"add byte ptr"* ]]; then
    echo -e "${GREEN}PASS: NUL bytes properly handled${NC}"
else
    echo -e "${RED}FAIL: NUL bytes not properly handled${NC}"
    echo "Output: $NUL_OUTPUT"
    exit 1
fi

# Test 12: Architecture specification
echo -e "${BLUE}Test #12: Architecture specification${NC}"
echo -ne '\x90\x90\xc3' > "$TMP_BINARY" # Two NOPs and a RET
ARCH_OUTPUT=$($SCRIPT -a --arch x64 "$TMP_BINARY" 2>&1)

# Check if it mentions specified architecture
if [[ "$ARCH_OUTPUT" == *"Using specified architecture"* ]]; then
    echo -e "${GREEN}PASS: Architecture specification works${NC}"
else
    echo -e "${RED}FAIL: Architecture specification not working${NC}"
    echo "Output: $ARCH_OUTPUT"
    exit 1
fi

# Print summary
echo -e "\n${BLUE}=== Test Suite Summary ===${NC}"
echo -e "${GREEN}All tests passed!${NC}"
exit 0